#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>typedef struct polynome* Position;typedef struct polynome{	int coef;	int pow;	Position next;}polynome;int getPolynome(Position, Position);int addingToList(Position, int, int);int add(Position, Position, Position);int multipl(Position, Position, Position);int print(Position);int del(Position);int main(){	polynome headAdd = { .coef = 0,.pow = 0,.next = NULL };	polynome polynome1 = headAdd;	polynome polynome2 = headAdd;	polynome headMultipl = headAdd;	getPolynome(&polynome1, &polynome2);	printf("Prvi polinom: \n");	print(polynome1.next);	printf("Drugi polinom: \n");	print(polynome2.next);	add(&headAdd, polynome1.next, polynome2.next);	multipl(&headMultipl, polynome1.next, polynome2.next);	printf("Suma: \n");	print(headAdd.next);	printf("Umnozak: \n");	print(headMultipl.next);	while (headAdd.next != NULL)		del(&headAdd);	while (headMultipl.next != NULL)		del(&headMultipl);	while (polynome1.next != NULL)		del(&polynome1);	while (polynome2.next != NULL)		del(&polynome2);	return 0;}int getPolynome(Position first, Position second){	FILE* fp1 = fopen("polynome1.txt", "r");	FILE* fp2 = fopen("polynome2.txt", "r");	if (fp1 == NULL || fp2 == NULL)	{		printf("Greska pri otvaranju datoteka!\n");		return -1;	}	int coef, ex;	while (!feof(fp1))		if (fscanf(fp1, "%d %d ", &coef, &ex) != 2)		{			printf("Problem pri ucitavanju iz datoteka!\n");			return -1;		}		if (coef != 0)			addingToList(first, coef, ex);	while (!feof(fp2))		if (fscanf(fp2, "%d %d ", &coef, &ex) != 2)		{			printf("Problem pri ucitavanju iz datoteka!\n");			return -1;		}		if (coef != 0)			addingToList(second, coef, ex);	fclose(fp1);	fclose(fp2);	return 0;}int addingToList(Position q, int a, int x){	Position nP = (Position)malloc(sizeof(polynome));	Position temp = q->next;	if (nP == NULL)	{		printf("Greska pri alokaciji memorije!\n");		return -1;	}	Position begin = q;	q = q->next;	nP->coef = a;	nP->pow = x;	int flag = 0;	while (temp != NULL)		if (nP->pow == temp->pow)		{			temp->coef += nP->coef;			return 0;		}		else			temp = temp->next;	while (!flag)		if (q == NULL)		{			nP->next = begin->next;			begin->next = nP;			flag = 1;		}		else if (q->pow > nP->pow)		{			begin = q;			q = q->next;		}		else		{			nP->next = q;			begin->next = nP;			flag = 1;		}	return 0;}int add(Position q, Position first, Position second){	while (first != NULL && second != NULL)	{		Position nE = (Position)malloc(sizeof(polynome));		if (first->pow > second->pow)		{			nE->coef = first->coef;			nE->pow = first->pow;			nE->next = q->next;			q->next = nE;			q = q->next;			first = first->next;		}		else if (first->pow < second->pow)		{			nE->coef = second->coef;			nE->pow = second->pow;			nE->next = q->next;			q->next = nE;			q = q->next;			second = second->next;		}		else		{			nE->coef = first->coef + second->coef;			nE->pow = first->pow;			nE->next = q->next;			q->next = nE;			q = q->next;			first = first->next;			second = second->next;		}	}	while (first != NULL)	{		Position nE = (Position)malloc(sizeof(polynome));		nE->coef = first->coef;		nE->pow = first->pow;		nE->next = q->next;		q->next = nE;		q = q->next;		first = first->next;	}	while (second != NULL)	{		Position nE = (Position)malloc(sizeof(polynome));		nE->coef = second->coef;		nE->pow = second->pow;		nE->next = q->next;		q->next = nE;		q = q->next;		second = second->next;	}	return 0;}int multipl(Position q, Position first, Position second){	Position second = second;	int c, p;	while (first != NULL)	{		while (second != NULL)		{			c = first->coef * second->coef;			p = first->pow + second->pow;			addingToList(q, c, p);			second = second->next;		}		first = first->next;		second = second;	}	return 0;}int print(Position q){	while (q != NULL)	{		if (q->coef != 0)			printf("%dx^%d\n", q->coef, q->pow);		q = q->next;	}	return 0;}int del(Position q){	Position Del;	Del = q->next;	q->next = Del->next;	Del->next = NULL;	free(Del);	return 0;}